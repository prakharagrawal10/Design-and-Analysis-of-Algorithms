=== task11.asm ===

ORG 0000H
MOV A,#05H //initializing A
MOV R0,#03H
ADD A,R0
MOV B,#04H//initializing B
MUL AB //muliplication of A and B
MOV R1,A
MOV A,#04H
MOV B,#02H
DIV AB //division of A and B
MOV R2,A
MOV A,#05H
MOV B,#05H
MUL AB
ADD A,R1
SUBB A,R2
//converting to BCD
MOV B,#10d
DIV AB
SWAP A
ADD A,B
END


=== task12.asm ===

ORG 0000H
MOV A,#05H
MOV B,#04H
CJNE A,B,OVER
INC R0
SJMP HALT
OVER:JNC FIRST
MOV R0,B
SJMP HALT
FIRST: MOV R0,A
HALT:SJMP HALT
END

=== task13.asm ===

ORG 0000H
	MOV 0005H,#12H
	MOV 0006H,#78H
	MOV 0007H,#11H
	MOV 0008H,#2H
	MOV 0009H,#1H
	MOV R2,#5H
LOOP1: MOV R0,#0005H
	   MOV R1,#5H
LOOP2: MOV A,@R0
	INC R0
	MOV B,@R0
	CJNE A,B,NEXT
	SJMP EQUAL
	NEXT: JC EQUAL
	MOV @R0,A
	DEC R0
	MOV @R0,B
	EQUAL: DJNZ R1,LOOP2
	       DJNZ R2,LOOP1
    MOV A,R5
	MOV B,R6
	MOV R5,B
	MOV R6,A
	NOP
	MOV R0,#05H
	MOV DPTR,#0100H
	MOV R1,#5H
	COPY: 
	      MOV A,@R0
		  MOVX @DPTR,A
		  INC R0
		  INC DPTR
		  DJNZ R1,COPY
	END

=== task21.asm ===

ORG 0000H
MOV R2,#4H
MOV R0,#40H
MOV DPTR,#120H
LOOP:CLR A
MOVC A,@A+DPTR
MOV R1,A
MOV A,#30H; 
MOVC A,@A+DPTR
ADDC A,R1
MOV B,#10d
DIV AB
SWAP A
ADD A,B
MOV @R0,A
INC R0
INC DPTR
DJNZ R2,LOOP
HERE: SJMP HERE
ORG 120H
	DATA_1:DB 14H,16H,15H,18H
ORG 150H
	DATA_2:DB 13H,16H,10H,18H
END

=== task22.asm ===

ORG 0000H
	MOV DPTR,#200H
	MOV R0,#10
LOOP:CLR A
	 MOVC A,@A+DPTR
	 ADD A,R2
	 JNC NEXT
	 INC R3
NEXT:INC DPTR
	 MOV R2,A
	 DJNZ R0,LOOP
HERE:SJMP HERE
ORG 200H
	MYDATA:DB 2H,4H,2H,3H,3H,7H,9H,3H,4H,7H
END

=== task23.asm ===

ORG 0000H
HERE:MOV P0,#55H
	 MOV P1,#55H
	 MOV P2,#55H
	 ACALL DELAY
	 MOV P0,#0AAH
	 MOV P1,#0AAH
	 MOV P2,#0AAH
	 ACALL DELAY
	 SJMP HERE
DELAY:MOV R1,#04H
BACK:MOV R2,#15H
AGAIN:DJNZ R2,AGAIN
	  DJNZ R1,BACK
	  RET
END

=== task31.asm ===

ORG 0000H
MOV P1, #00000100B   ; Configure P1.2 as input
MOV SCON, #50H       ; Initialize serial mode register for 8-bit UART
MOV TMOD, #20H       ; Timer1, mode 2
SETB TR1             ; Start timer1
SETB TI              ; Set transmit flag
CHECK_SW:
  JB P1.2, BAUD_9600   ; If SW is high, set baud rate to 9600
  MOV TH1, #-6      ; Load baud rate generator for 4800 baud rate
  SJMP START_SEND
BAUD_9600:
  MOV TH1, #-3       ; Load baud rate generator for 9600 baud rate
START_SEND:
  MOV DPTR, #MSG        ; Load address of message string
  MOV R7, #22          ; Set counter for message length
SEND_NEXT:
CLR A
  MOVC A, @A+DPTR          ; Load next character from message
  ACALL SEND_SERIAL     ; Send the character serially
  INC DPTR              ; Move to next character in message
  DJNZ R7, SEND_NEXT    ; Repeat until all characters are sent
  SJMP CHECK_SW           ; Infinite loop
SEND_SERIAL:
  JNB TI, $           ; Wait until previous byte is transmitted
  MOV SBUF, A         ; Load data to be sent into serial buffer
  CLR TI              ; Clear transmit flag
  RET
MSG: DB 'riviera revive the era' ; Message to be sent
END


=== task32.asm ===

ORG 0000h

MOV SCON, #50H   ; Initialize serial mode register for mode 1 (8-bit UART)
MOV TMOD, #20H   ; Timer1, mode 2
MOV TH1, #-3   ; Load baud rate generator for 9600 baud rate
SETB TR1         ; Start timer1
SETB TI          ; Set transmit flag

MAIN:
  MOV A, #65    ; Load data to be sent (ASCII 'A')
  ACALL SEND_SERIAL
  SJMP MAIN

SEND_SERIAL:
  JNB TI, $     ; Wait until previous byte is transmitted
  MOV SBUF, A   ; Load data to be sent into serial buffer
  CLR TI        ; Clear transmit flag
  RET

END



=== task33.asm ===

ORG 0000H
LJMP MAIN
ORG 000BH
CPL P2.1
RETI
ORG 0030H
MAIN: MOV TMOD,#02H
MOV P0,#0FFH
MOV TH0,#0A3H
MOV IE,#10000010B
SETB TR0
BACK: MOV A,P0
MOV P1,A
SJMP BACK
END 

=== task34.asm ===

ORG 0000h    ; Start address of the program
MOV P1, #0FFH  ; Clear Port 1
;MOV P2, #00H  ; Clear Port 2
MOV SCON, #50H  ; Set Serial control register for mode 1
MOV TMOD, #20H  ; Set Timer 1 mode for 8-bit auto-reload
MOV TH1, #-3   ; Set Timer 1 reload value for baud rate 9600 at XTAL = 11.0592 MHz
SETB TR1       ; Start Timer 1
MAIN_LOOP:
    MOV A, P1   ; Read data from Port 1
    MOV P2, A   ; Write data to Port 2
    MOV SBUF, A  ; Load data into serial buffer
WAIT_FOR_TX:
    JNB TI, WAIT_FOR_TX  ; Wait until transmission is complete
    CLR TI               ; Clear transmission flag for next byte
    SJMP MAIN_LOOP  ; Repeat the loop
END

=== task41.asm ===

ORG 0000h    ; Start address of the program
MOV P1, #0FFH  ; Clear Port 1
;MOV P2, #00H  ; Clear Port 2
MOV SCON, #50H  ; Set Serial control register for mode 1
MOV TMOD, #20H  ; Set Timer 1 mode for 8-bit auto-reload
MOV TH1, #-3   ; Set Timer 1 reload value for baud rate 9600 at XTAL = 11.0592 MHz
SETB TR1       ; Start Timer 1
MAIN_LOOP:
    MOV A, P1   ; Read data from Port 1
    MOV P2, A   ; Write data to Port 2
    MOV SBUF, A  ; Load data into serial buffer
WAIT_FOR_TX:
    JNB TI, WAIT_FOR_TX  ; Wait until transmission is complete
    CLR TI               ; Clear transmission flag for next byte
    SJMP MAIN_LOOP  ; Repeat the loop
END

=== task42.asm ===

ORG 0000H
LJMP MAIN
ORG 000BH
CPL P2.1
RETI
ORG 0030H
MAIN: MOV TMOD,#02H
MOV P0,#0FFH
MOV TH0,#0D2H
MOV IE,#10000010B
SETB TR0
BACK: MOV A,P0
MOV P1,A
SJMP BACK
END 

=== task43.asm ===

ORG 0
LJMP MAIN
ORG 000BH ;ISR vector address for Timer-0 overflow Interrupt.
CPL P0.1 ;toggle P0.1; ISR for Timer-0 overflow Interrupt, runs when TF0=1.
RETI ;return from ISR to main program
ORG 0023H ;ISR vector address for serial communication Interrupt as show in above table.
LJMP SERIAL ;jump to serial interrupt ISR
ORG 30H
MAIN: MOV IE,10010010B ;enable timer overflow for timer-0, serial (RI/TI) interrupts.
;-------solving part-b of the question--------continuation to above code----------
MOV P1,#0FFH ;make P1 an input port
MOV SCON,#50H ;8-bit data frame, 1 stop, REN enabled
MOV TMOD,#20H 
MOV TH1,#-6H ;for 4800 baud rate, initial value for timer-1 mode-0
SETB TR1 ;start timer 1
BACK: MOV A,P1 ;read data from port 1
MOV SBUF,A ;give a copy to SBUF
MOV P2,A ;send it to P2
SJMP BACK ;stay in loop indefinitely
;-------solving part-c of the question--------continuation to above code----------
MOV TMOD, #02H
MOV TL0,#0E9H ;
SETB TR0 ;start timer 0
;-----SERIAL PORT ISR for solving part-a of the question------continuation to previous code---
;----this part of the code will execute when ever TI/RI interrupts come.
ORG 100H
SERIAL:JB TI,TRANS ;jump if TI is high
MOV A,SBUF ;otherwise due to receive
MOV P0,A ;send serial data to P0
CLR RI ;clear RI since CPU doesn’t
RETI ;return from ISR
TRANS: CLR TI ;clear TI since CPU doesn’t
RETI ;return from ISR
END

=== task432.asm ===

ORG 0
    LJMP MAIN ; Jump to the main program

ORG 23H ; Serial Interrupt Vector
    LJMP SERIAL_ISR ; Jump to serial interrupt service routine

ORG 0BH ; Timer 0 Overflow Interrupt Vector
    LJMP TIMER0_ISR ; Jump to Timer 0 overflow interrupt service routine

MAIN:
    MOV IE, #0x92 ; Enable Timer 0 overflow and serial interrupts

    ; Serial port configuration
    MOV TMOD, #20H ; Timer 1, mode 2 
    MOV TH1, #-3 ; Set TH1 for 4800 baud rate
    MOV SCON, #50H ; Mode 1, 8-bit UART, 
    ; Timer 0 configuration for square wave generation
    MOV TMOD, #02H ; Timer 0, mode 1 (16-bit timer)
    MOV TH0, #0 ; Initial value for Timer 0 (High byte)
    MOV TL0, #0E9H ; Initial value for Timer 0 (Low byte)
    SETB TR0 ; Start Timer 0

    MOV P1, #0FFH ; Make P1 an input port

MAIN_LOOP:
    SJMP MAIN_LOOP ; Endless loop

SERIAL_ISR:
    JB TI, SERIAL_TX ; Jump if TI is set (transmit interrupt)
    MOV A, SBUF ; Receive data from serial port
    MOV P0, A ; Output received data to P0
    CLR RI ; Clear receive interrupt flag
    RETI ; Return from interrupt

SERIAL_TX:
    CLR TI ; Clear transmit interrupt flag
    MOV A, P1 ; Read data from P1
    MOV SBUF, A ; Transmit data from P1
    MOV P2, A ; Output data from P1 to P2
    RETI ; Return from interrupt

TIMER0_ISR:
    CPL P0.1 ; Toggle P0.1 for square wave generation
    RETI ; Return from interrupt

END


=== task5.asm ===

MOV P2,#0FFH ;make P2 an input port
K1: MOV P1,#0 ;ground all rows at once
 MOV A,P2 ;read all col. ensure all keys open
 ANL A,#00001111B ;masked unused bits
 CJNE A,#00001111B,K1 ;check till all keys released
K2: ACALL DELAY ;call 20 ms delay
 MOV A,P2 ;see if any key is pressed
 ANL A,#00001111B ;mask unused bits
 CJNE A,#00001111B,OVER ;key pressed, await closure
 SJMP K2 ;check if key pressed
OVER: ACALL DELAY ;wait 20 ms debounce time
 MOV A,P2 ;check key closure
 ANL A,#00001111B ;mask unused bits
 CJNE A,#00001111B,OVER1 ;key pressed, find row
 SJMP K2 ;if none, keep polling
OVER1: MOV P1,#11111110B ;ground row 0
 MOV A,P2 ;read all columns
 ANL A,#00001111B ;mask unused bits
 CJNE A,#00001111B,ROW_0 ;key row 0, find the col.
 MOV P1,#11111101B ;ground row 1
 MOV A,P2 ;read all columns
 ANL A,#00001111B ;mask unused bits
 CJNE A,#00001111B,ROW_1 ;key row 1, find the col.
 MOV P1,#11111011B ;ground row 2
 MOV A,P2 ;read all columns
 ANL A,#00001111B ;mask unused bits
 CJNE A,#00001111B,ROW_2 ;key row 2, find the col.
 MOV P1,#11110111B ;ground row 3
 MOV A,P2
 ANL A,#00001111B ;mask unused bits
 CJNE A,#00001111B,ROW_3 ;key row 3, find the col.
 LJMP K2 ;if none, false input, repeat

ROW_0: MOV DPTR,#KCODE0 ;set DPTR=start of row 0
SJMP FIND ;find col. key belongs to
ROW_1: MOV DPTR,#KCODE1 ;set DPTR=start of row 1
 SJMP FIND ;find col. key belongs to
ROW_2: MOV DPTR,#KCODE2 ;set DPTR=start of row 2
 SJMP FIND ;find col. key belongs to
ROW_3: MOV DPTR,#KCODE3 ;set DPTR=start of row 3
FIND: RRC A ;see if any CY bit is low
 JNC MATCH ;if zero, get the ASCII code
 INC DPTR ;point to next col. address
 SJMP FIND ;keep searching
MATCH: CLR A ;set A=0 (match is found)
 MOVC A,@A+DPTR ;get ASCII code from table
MOV P0,A ;display pressed key
DELAY: MOV R3,#05H
MOV R4,#01H
MOV R5,#02H
HERE: DJNZ R5,HERE
HERE1: DJNZ R4, HERE1 
HERE2: DJNZ R3,HERE2
 LJMP K1
 
;ASCII LOOK-UP TABLE FOR EACH ROW
 ORG 300H
KCODE0: DB '0','1','2','3' ;ROW 0
KCODE1: DB '4','5','6','7' ;ROW 1
KCODE2: DB '8','9','A','B' ;ROW 2
KCODE3: DB 'C','D','E','F' ;ROW 3
 END

=== task51.asm ===

ORG 0000H
MOV A,#38H
ACALL CMNWRT
ACALL DELAY
MOV A,#0EH
ACALL CMNWRT
ACALL DELAY
MOV A,#01H
ACALL CMNWRT
ACALL DELAY
MOV A,#06H
ACALL CMNWRT
ACALL DELAY
MOV A,#80H
ACALL CMNWRT
ACALL DELAY
MOV A,#'A'
ACALL DATWRT
ACALL DELAY
MOV A,#'M'
ACALL DATWRT
ACALL DELAY
MOV A,#'A'
ACALL DATWRT
ACALL DELAY
MOV A,#'N'
ACALL DATWRT
ACALL DELAY
MOV A,#' '
ACALL DATWRT
ACALL DELAY
MOV A,#'M'
ACALL DATWRT
ACALL DELAY
MOV A,#'I'
ACALL DATWRT
ACALL DELAY
MOV A,#'S'
ACALL DATWRT
ACALL DELAY
MOV A,#'H'
ACALL DATWRT
ACALL DELAY
MOV A,#'R'
ACALL DATWRT
ACALL DELAY
MOV A,#'A'
ACALL DATWRT
ACALL DELAY
AGAIN: SJMP AGAIN
CMNWRT:
MOV P1,A
CLR P2.0
CLR P2.1
SETB P2.2
CLR P2.2
RET
DATWRT:
MOV P1,A
SETB P2.0
CLR P2.1
SETB P2.2
CLR P2.2
RET
DELAY: MOV R3,#05H
MOV R4,#01H
MOV R5,#02H
HERE: DJNZ R5,HERE
HERE1: DJNZ R4, HERE1 
HERE2: DJNZ R3,HERE2
RET
END
 





=== task52.asm ===

ORG 0000H
 MOV DPTR,#MYCOM
 MOV R0,#05H
C1: CLR A
MOVC A,@A+DPTR
ACALL COMNWRT ;call command subroutine
 ACALL DELAY ;give LCD some time
INC DPTR
DJNZ R0,C1
COMNWRT: ;send command to LCD
 MOV P0,A ;SEND COMND to P1
 CLR P2.4 ;RS=0 for command
 CLR P2.5 ;R/W=0 for write
 SETB P2.6 ;E=1 for high pulse
 ACALL DELAY ;give LCD some time
 CLR P2.6 ;E=0 for H-to-L
 RET
MOV P2,#0FFH ;make P2 an input port
K1: MOV P1,#0 ;ground all rows at once
 MOV A,P2 ;read all col. ensure all keys open
 ANL A,#00001111B ;masked unused bits
 CJNE A,#00001111B,K1 ;check till all keys released
K2: ACALL DELAY ;call 20 ms delay
 MOV A,P2 ;see if any key is pressed
 ANL A,#00001111B ;mask unused bits
 CJNE A,#00001111B,OVER ;key pressed, await closure
 SJMP K2 ;check if key pressed
OVER: ACALL DELAY ;wait 20 ms debounce time
 MOV A,P2 ;check key closure
 ANL A,#00001111B ;mask unused bits
 CJNE A,#00001111B,OVER1 ;key pressed, find row
 SJMP K2 ;if none, keep polling
OVER1: MOV P1,#11111110B ;ground row 0
 MOV A,P2 ;read all columns
 ANL A,#00001111B ;mask unused bits
 CJNE A,#00001111B,ROW_0 ;key row 0, find the col.
 MOV P1,#11111101B ;ground row 1
 MOV A,P2 ;read all columns
 ANL A,#00001111B ;mask unused bits
 CJNE A,#00001111B,ROW_1 ;key row 1, find the col.
 MOV P1,#11111011B ;ground row 2
 MOV A,P2 ;read all columns
 ANL A,#00001111B ;mask unused bits
 CJNE A,#00001111B,ROW_2 ;key row 2, find the col.
 MOV P1,#11110111B ;ground row 3
 MOV A,P2 ;read all columns
 ANL A,#00001111B ;mask unused bits
 CJNE A,#00001111B,ROW_3 ;key row 3, find the col.
 LJMP K2 ;if none, false input, repeat
ROW_0: MOV DPTR,#KCODE0 ;set DPTR=start of row 0
SJMP FIND ;find col. key belongs to
ROW_1: MOV DPTR,#KCODE1 ;set DPTR=start of row 1
 SJMP FIND ;find col. key belongs to
ROW_2: MOV DPTR,#KCODE2 ;set DPTR=start of row 2
 SJMP FIND ;find col. key belongs to
ROW_3: MOV DPTR,#KCODE3 ;set DPTR=start of row 3
FIND: RRC A ;see if any CY bit is low
 JNC MATCH ;if zero, get the ASCII code
 INC DPTR ;point to next col. address
 SJMP FIND ;keep searching
MATCH: CLR A ;set A=0 (match is found)
 MOVC A,@A+DPTR ;get ASCII code from table
MOV P0,A
ACALL DATAWRT ;call command subroutine
ACALL DELAY ;give LCD some time
LJMP K1
HERE: SJMP HERE
DATAWRT:
 SETB P2.4 ;RS=1 for data
 CLR P2.5 ;R/W=0 for write
 SETB P2.6 ;E=1 for high pulse
 ACALL DELAY ;give LCD some time
 CLR P2.6 ;E=0 for H-to-L pulse
 RET
DELAY: 
MOV R3,#255 ;LONG DELAY FOR fast CPUs
HERE2: MOV R4,#255 ;
HERE3: DJNZ R4,HERE3 ;
 DJNZ R3,HERE2
 RET
ORG 300H
KCODE0: DB '0','1','2','3' ;ROW 0
KCODE1: DB '4','5','6','7' ;ROW 1
KCODE2: DB '8','9','A','B' ;ROW 2
KCODE3: DB 'C','D','E','F' ;ROW 3
ORG 200H
MYCOM: DB 38H,0EH,01,06,84H ;commands and null
 END


=== task5s.asm ===

ORG 0000H
MOV A,#38H
ACALL CMNWRT
ACALL DELAY
MOV A,#0EH
ACALL CMNWRT
ACALL DELAY
MOV A,#01H
ACALL CMNWRT
ACALL DELAY
MOV A,#06H
ACALL CMNWRT
ACALL DELAY
MOV A,#80H
ACALL CMNWRT
ACALL DELAY
MOV A,#'S'
ACALL DATWRT
ACALL DELAY
MOV A,#'H'
ACALL DATWRT
ACALL DELAY
MOV A,#'R'
ACALL DATWRT
ACALL DELAY
MOV A,#'A'
ACALL DATWRT
ACALL DELAY
MOV A,#'E'
ACALL DATWRT
ACALL DELAY
MOV A,#'Y'
ACALL DATWRT
ACALL DELAY
MOV A,#'A'
ACALL DATWRT
ACALL DELAY
MOV A,#' '
ACALL DATWRT
ACALL DELAY
MOV A,#'B'
ACALL DATWRT
ACALL DELAY
MOV A,#'O'
ACALL DATWRT
ACALL DELAY
MOV A,#'T'
ACALL DATWRT
ACALL DELAY
MOV A,#'U'
ACALL DATWRT
ACALL DELAY
MOV A,#'K'
ACALL DATWRT
ACALL DELAY
MOV A,#'U'
ACALL DATWRT
ACALL DELAY
AGAIN: SJMP AGAIN
CMNWRT:
MOV P1,A
CLR P2.0
CLR P2.1
SETB P2.2
CLR P2.2
RET
DATWRT:
MOV P1,A
SETB P2.0
CLR P2.1
SETB P2.2
CLR P2.2
RET
DELAY: MOV R3,#05H
MOV R4,#01H
MOV R5,#02H
HERE: DJNZ R5,HERE
HERE1: DJNZ R4, HERE1 
HERE2: DJNZ R3,HERE2
RET
END

=== varun.asm ===

ORG 0
    LJMP MAIN ; Jump to the main program

ORG 23H ; Serial Interrupt Vector
    LJMP SERIAL_ISR ; Jump to serial interrupt service routine

ORG 0BH ; Timer 0 Overflow Interrupt Vector
    LJMP TIMER0_ISR ; Jump to Timer 0 overflow interrupt service routine

MAIN:
    MOV IE, #0x92 ; Enable Timer 0 overflow and serial interrupts

    ; Serial port configuration
    MOV TMOD, #20H ; Timer 1, mode 2 (8-bit auto-reload)
    MOV TH1, #-3 ; Set TH1 for 4800 baud rate
    MOV SCON, #50H ; Mode 1, 8-bit UART, enable receiver

    ; Timer 0 configuration for square wave generation
    MOV TMOD, #02H ; Timer 0, mode 1 (16-bit timer)
    MOV TH0, #0 ; Initial value for Timer 0 (High byte)
    MOV TL0, #0E9H ; Initial value for Timer 0 (Low byte)
    SETB TR0 ; Start Timer 0

    MOV P1, #0FFH ; Make P1 an input port

MAIN_LOOP:
    SJMP MAIN_LOOP ; Endless loop

SERIAL_ISR:
    JB TI, SERIAL_TX ; Jump if TI is set (transmit interrupt)
    MOV A, SBUF ; Receive data from serial port
    MOV P0, A ; Output received data to P0
    CLR RI ; Clear receive interrupt flag
    RETI ; Return from interrupt

SERIAL_TX:
    CLR TI ; Clear transmit interrupt flag
    MOV A, P1 ; Read data from P1
    MOV SBUF, A ; Transmit data from P1
    MOV P2, A ; Output data from P1 to P2
    RETI ; Return from interrupt

TIMER0_ISR:
    CPL P0.1 ; Toggle P0.1 for square wave generation
    RETI ; Return from interrupt

END


